<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>チェイス＆ハイド</title>
    <style>
      :root {
        --hex-size: 40px;
        --board-bg: #f0f0f0;
        --hex-bg: #ffffff;
        --player-color: #3498db;
        /* mobの色はJSで設定 */
        --highlight-color: rgba(52, 152, 219, 0.3);
        --font-family: 'Inter', 'Noto Sans JP', sans-serif;
      }

      body {
        font-family: var(--font-family);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        margin: 0;
        padding: 5px 0;
        background-color: #e9ebee;
        color: #333;
      }

      .game-container {
        display: flex; /* 最初から表示 */
        flex-direction: column;
        align-items: center;
        gap: 10px;
        padding: 10px;
        background-color: white;
        border-radius: 16px;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
        width: 95%;
        max-width: 1200px;
        /* min-height はJSで調整 */
      }

      .game-info {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-around;
        width: 100%;
        gap: 10px;
        margin-bottom: 0;
        font-size: 1.2em;
        font-weight: bold;
        text-align: center;
      }

      .info-box {
        background-color: #f8f9fa;
        padding: 10px 20px;
        border-radius: 12px;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
      }

      #game-board {
        position: relative;
        background-color: var(--board-bg);
        border-radius: 12px;
        overflow: hidden; /* はみ出たヘクスを隠す */
        /* transform: scale() はJSで動的に設定 */
        margin: 0 auto; /* 中央寄せにしつつ、上下マージンは0 */
      }

      .hex {
        position: absolute;
        width: calc(var(--hex-size) * 2);
        height: calc(var(--hex-size) * 2 * 0.866);
        background-color: var(--hex-bg);
        clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
        transition: background-color 0.3s ease, transform 0.2s ease;
        cursor: pointer;
        z-index: 1;
      }

      .hex:hover {
        transform: scale(1.05);
        z-index: 2;
      }

      .hex.placeable-trap-highlight {
        background-color: rgba(46, 204, 113, 0.4); /* 緑系のハイライト */
      }

      .trap-piece {
        background-color: #95a5a6; /* 罠っぽい色 */
        box-shadow: 0 0 8px #7f8c8d;
        font-size: calc(var(--hex-size) * 0.5);
        color: #2c3e50;
        pointer-events: none; /* クリックイベントを透過させる */
        /* piece共通スタイルを継承 */
      }

      .hex.highlight {
        background-color: var(--highlight-color);
      }

      .hex.detection-highlight {
        background-color: rgba(255, 165, 0, 0.3);
      }

      .item-piece {
        background-color: #2ecc71;
        box-shadow: 0 0 8px #2ecc71;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        color: white;
        font-size: calc(var(--hex-size) * 0.5);
        pointer-events: none;
        /* z-index は piece 共通で設定し、mobで上書き */
      }

      .piece {
        position: absolute;
        top: 0;
        left: 0;
        border-radius: 50%;
        transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55), opacity 0.3s ease; /* opacityもトランジション対象に */
        z-index: 5; /* 基本のz-index */
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .player {
        background-color: var(--player-color);
        box-shadow: 0 0 10px var(--player-color);
        pointer-events: none;
      }

      .mob {
        pointer-events: none;
        z-index: 6; /* アイテムより手前に表示 */
      }

      .mob-level {
        color: white;
        font-size: calc(var(--hex-size) * 0.4);
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }

      .message-area {
        height: auto;
        line-height: 1.2;
        font-size: 1em;
        color: #555;
        font-weight: 500;
        text-align: center;
      }

      button {
        background-color: var(--player-color);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 1em;
        cursor: pointer;
        transition: background-color 0.2s, transform 0.2s;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      }

      button:hover {
        background-color: #2980b9;
        transform: translateY(-2px);
      }

      button:disabled {
        background-color: #bdc3c7;
        color: #7f8c8d;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
      }
      .inventory-area {
        display: flex;
        gap: 15px;
        align-items: center;
        margin-top: 5px;
        padding: 10px;
        background-color: #f0f0f0;
        border-radius: 8px;
      }
      .inventory-item {
        font-weight: 500;
      }
      .item-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: calc(var(--hex-size) * 0.6);
        height: calc(var(--hex-size) * 0.6);
        background-color: #2ecc71;
        color: white;
        font-weight: bold;
        border-radius: 50%;
        font-size: calc(var(--hex-size) * 0.4);
        margin-right: 5px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <style>
        h1 {
          margin-top: 0;
          margin-bottom: 5px;
        }
        .game-controls {
          display: flex;
          align-items: center;
          gap: 15px;
          margin-top: 10px;
        }
      </style>
      <h1>チェイス＆ハイド</h1>
      <div class="game-info">
        <div class="info-box">スコア: <span id="score">0</span></div>
        <div class="info-box">ターン: <span id="turn">1</span></div>
      </div>

      <div id="game-board"></div>

      <div id="message-area" class="message-area">あなたのターンです。</div>

      <div id="inventory-area" class="inventory-area"></div>

      <div class="game-controls">
        <button id="restart-button">ゲームをリセット</button>
        <div>
          <label for="map-size-selector">マップサイズ (半径): </label>
          <select id="map-size-selector">
            <option value="4">小 (4)</option>
            <option value="5" selected>中 (5)</option>
            <option value="6">大 (6)</option>
            <option value="7">特大 (7)</option>
          </select>
        </div>
      </div>
    </div>

    <script>
      // --- ゲーム設定 (グローバル定数からgameStateプロパティへ移行) ---
      const ITEM_SPAWN_CHANCE = 0.1
      const ITEM_TYPES = ['boots', 'cloak', 'snare_trap'] // スネアトラップを追加
      const CLOAK_DURATION = 3
      const CLOAK_EVASION_CHANCE = 0.7
      const SNARE_TRAP_DURATION = 5 // 設置後の持続ターン数
      const SNARE_TRAP_STUN_TURNS = 2 // モブの行動不能ターン数
      const MOB_SPAWN_CHANCE_PER_TURN = 1.0 // 毎ターン新しいモンスターが出現する確率 (90%)

      const MOB_STATS = {
        1: { detectionRange: 2, color: '#f1c40f', score: 5 },
        2: { detectionRange: 3, color: '#e67e22', score: 10 },
        3: { detectionRange: 4, color: '#e74c3c', score: 20 },
        4: { detectionRange: 5, color: '#c0392b', score: 40 },
        5: { detectionRange: 6, color: '#922b21', score: 75 },
      }

      const MOB_LEVEL_SPAWN_PARAMS = {
        1: { baseAttractiveness: 200, scoreMultiplier: -0.2 }, // 初期に非常に優勢、スコア上昇で急激に減少
        2: { baseAttractiveness: 80, scoreMultiplier: -0.1 }, // 初期に優勢、スコア上昇で緩やかに減少
        3: { baseAttractiveness: 30, scoreMultiplier: 0.1 }, // 中盤から徐々に増加
        4: { baseAttractiveness: 10, scoreMultiplier: 0.2 }, // スコアがある程度上がると出現率が大きく上昇
        5: { baseAttractiveness: 2, scoreMultiplier: 0.1 }, // 高スコア帯での主力、初期は稀
      }

      // --- DOM要素 ---
      const gameBoard = document.getElementById('game-board')
      const scoreEl = document.getElementById('score')
      const turnEl = document.getElementById('turn')
      const messageEl = document.getElementById('message-area')
      const restartButton = document.getElementById('restart-button')
      const inventoryArea = document.getElementById('inventory-area')

      const gameContainerEl = document.querySelector('.game-container')
      const mapSizeSelector = document.getElementById('map-size-selector')

      let gameState = {}

      const Axial = {
        add: (a, b) => ({ q: a.q + b.q, r: a.r + b.r }),
        subtract: (a, b) => ({ q: a.q - b.q, r: a.r - b.r }),
        distance: (a, b) => {
          const vec = Axial.subtract(a, b)
          return (Math.abs(vec.q) + Math.abs(vec.q + vec.r) + Math.abs(vec.r)) / 2
        },
        neighbors: (hex) => [
          { q: hex.q + 1, r: hex.r },
          { q: hex.q - 1, r: hex.r },
          { q: hex.q, r: hex.r + 1 },
          { q: hex.q, r: hex.r - 1 },
          { q: hex.q + 1, r: hex.r - 1 },
          { q: hex.q - 1, r: hex.r + 1 },
        ],
      }

      function initGame(selectedRadius) {
        gameState = {
          gridRadius: selectedRadius,
          grid: new Map(),
          player: { pos: { q: 0, r: 0 }, el: null },
          mobs: [],
          itemsOnBoard: [],
          score: 0,
          turn: 1,
          isPlayerTurn: true,
          isGameOver: false,
          trapsOnBoard: [], // 設置されたトラップを管理
          nextMobId: 0, // モブIDのカウンター
          nextItemId: 0, // アイテムIDのカウンター
          nextTrapId: 0, // トラップIDのカウンター
          isPlacingTrap: null, // トラップ設置モードの状態 (null or 'snare_trap')
        }
        gameState.player.inventory = [
          { type: 'boots', quantity: 0, name: 'ダッシュブーツ', icon: 'B' },
          { type: 'cloak', quantity: 0, name: '隠れ蓑', icon: 'C' },
          { type: 'snare_trap', quantity: 0, name: 'スネアトラップ', icon: 'S' },
        ]
        gameState.player.remainingMovesThisTurn = 1
        gameState.player.cloakTurnsLeft = 0

        // マップサイズに応じたバランスパラメータの計算
        const baseRadiusForBalance = 5
        const radiusRatio = Math.max(0.5, selectedRadius / baseRadiusForBalance)

        gameState.initialMobs = Math.max(2, Math.floor(4 * radiusRatio))
        gameState.minSpawnDistance = Math.max(2, Math.floor(3 * radiusRatio))
        gameState.minSpawnDistanceFromOtherMobs = Math.max(1, Math.floor(2 * radiusRatio))
        gameState.maxItemsOnBoard = Math.max(1, Math.floor(3 * radiusRatio))
        gameState.minItemSpawnDistanceFromPlayer = Math.max(1, Math.floor(2 * radiusRatio))

        // ヘクスサイズの決定 (clientWidthに依存しないように変更)
        // マップ半径に応じてヘクスサイズを段階的に設定
        let newHexSize = 40 // デフォルト
        if (selectedRadius >= 7) {
          // 半径7以上の場合
          newHexSize = 30
        } else if (selectedRadius >= 6) {
          // 半径6の場合
          newHexSize = 35
        }
        // 最小ヘクスサイズは15pxとする
        newHexSize = Math.max(15, newHexSize)
        document.documentElement.style.setProperty('--hex-size', `${newHexSize}px`)

        for (let q = -gameState.gridRadius; q <= gameState.gridRadius; q++) {
          for (let r = -gameState.gridRadius; r <= gameState.gridRadius; r++) {
            if (Math.abs(q + r) > gameState.gridRadius) continue
            gameState.grid.set(`${q},${r}`, { q, r, el: null })
          }
        }

        for (let i = 0; i < gameState.initialMobs; i++) {
          spawnNewMob(true)
        }

        // --hex-size の設定がDOMに反映された後に盤面を描画する
        function drawBoardWhenReady() {
          const currentHexSizeStyle = parseFloat(
            getComputedStyle(document.documentElement).getPropertyValue('--hex-size')
          )
          // 設定したnewHexSizeと、実際にgetComputedStyleで取得できる値が一致するか確認
          if (Math.abs(currentHexSizeStyle - newHexSize) < 0.1) {
            // 浮動小数点数の比較のため、わずかな誤差を許容
            drawBoard()
            updateInfo()
            updateInventoryUI()
            updateMessage('あなたのターンです。移動したいマスを選択してください。')
          } else {
            // まだスタイルが反映されていない場合、次のフレームで再試行
            requestAnimationFrame(drawBoardWhenReady)
          }
        }
        // drawBoardWhenReady を最初のフレームで呼び出し開始
        // これにより、--hex-size の設定が確実にDOMに反映されるのを待つ
        requestAnimationFrame(drawBoardWhenReady)
      }

      function drawBoard() {
        gameBoard.innerHTML = ''
        const hexSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hex-size'))
        const hexFullHeight = hexSize * Math.sqrt(3)
        const hexFullWidth = hexSize * 2

        let minX = Infinity,
          maxX = -Infinity,
          minY = Infinity,
          maxY = -Infinity
        const hexPositions = [] // Store calculated positions

        // 1. Calculate all hex positions relative to a virtual (0,0) center
        //    and determine the bounding box of all hexes.
        gameState.grid.forEach((hexData) => {
          const centerX = hexSize * 1.5 * hexData.q
          const centerY = hexFullHeight * (hexData.r + hexData.q / 2)
          hexPositions.push({ hexData, centerX, centerY })

          minX = Math.min(minX, centerX - hexSize) // Left edge of hex
          maxX = Math.max(maxX, centerX + hexSize) // Right edge of hex
          minY = Math.min(minY, centerY - hexFullHeight / 2) // Top edge of hex
          maxY = Math.max(maxY, centerY + hexFullHeight / 2) // Bottom edge of hex
        })

        // 2. Determine the actual width and height of the game board
        //    by adding padding to the bounding box.
        const boardContentWidth = maxX - minX
        const boardContentHeight = maxY - minY
        const boardPadding = hexSize * 4 // グレーの枠の余白をさらに大幅に増やす (ヘクスサイズの4倍)

        const boardWidth = boardContentWidth + boardPadding * 2
        const boardHeight = boardContentHeight + boardPadding * 2

        gameBoard.style.width = `${boardWidth}px`
        gameBoard.style.height = `${boardHeight}px`

        // 3. Position each hex absolutely within the game board.
        //    The offset is (centerX - minX + boardPadding - hexSize)
        //    (centerX - minX) gives position relative to the leftmost point of hex content.
        //    + boardPadding shifts it by the padding amount.
        //    - hexSize (or -hexFullHeight/2) adjusts from center to top-left for absolute positioning.
        hexPositions.forEach(({ hexData, centerX, centerY }) => {
          const hexEl = document.createElement('div')
          hexEl.className = 'hex'
          hexEl.style.left = `${centerX - minX + boardPadding - hexSize}px`
          hexEl.style.top = `${centerY - minY + boardPadding - hexFullHeight / 2}px`

          hexEl.dataset.q = hexData.q
          hexEl.dataset.r = hexData.r

          hexEl.addEventListener('click', () => onHexClick(hexData.q, hexData.r))
          hexEl.addEventListener('mouseenter', () => onHexMouseEnter(hexData))
          hexEl.addEventListener('mouseleave', () => onHexMouseLeave())

          hexData.el = hexEl
          gameBoard.appendChild(hexEl)
        })

        const gameInfoHeight = document.querySelector('.game-info').offsetHeight
        const messageAreaHeight = messageEl.offsetHeight
        const inventoryAreaHeight = inventoryArea.offsetHeight
        const restartButtonHeight = restartButton.offsetHeight
        const containerGap = parseFloat(getComputedStyle(gameContainerEl).gap) || 10 // gapのデフォルト値を10pxとする
        const containerPaddingVertical =
          parseFloat(getComputedStyle(gameContainerEl).paddingTop) +
          parseFloat(getComputedStyle(gameContainerEl).paddingBottom)

        gameContainerEl.style.height = `${
          boardHeight +
          gameInfoHeight +
          messageAreaHeight +
          inventoryAreaHeight +
          restartButtonHeight +
          containerGap * 4 +
          containerPaddingVertical
        }px`

        createOrUpdatePiece(gameState.player, 'player')
        gameState.mobs.forEach((mob) => createOrUpdatePiece(mob, 'mob'))
        gameState.itemsOnBoard.forEach((item) => createOrUpdateItemPiece(item))
        gameState.trapsOnBoard.forEach((trap) => createOrUpdateTrapPiece(trap))
        updateHighlights()
      }

      function createOrUpdatePiece(pieceData, type) {
        const hexSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hex-size'))
        const pieceSize = hexSize * 0.8

        if (!pieceData.el) {
          pieceData.el = document.createElement('div')
          pieceData.el.className = `piece ${type}`
          pieceData.el.style.width = `${pieceSize}px`
          pieceData.el.style.height = `${pieceSize}px`
          gameBoard.appendChild(pieceData.el)
        }

        if (type === 'mob') {
          const stats = MOB_STATS[pieceData.level]
          pieceData.el.style.backgroundColor = stats.color

          let levelEl = pieceData.el.querySelector('.mob-level')
          if (!levelEl) {
            levelEl = document.createElement('span')
            levelEl.className = 'mob-level'
            pieceData.el.appendChild(levelEl)
          }
          levelEl.textContent = pieceData.level
        }
        // スタン状態の視覚的表現
        if (type === 'mob' && pieceData.stunnedTurns > 0) {
          pieceData.el.style.opacity = '0.5'
        } else if (type === 'mob') {
          pieceData.el.style.opacity = '1'
        }

        const hexKey = `${pieceData.pos.q},${pieceData.pos.r}`
        const hexOnBoard = gameState.grid.get(hexKey)
        if (!hexOnBoard || !hexOnBoard.el) return

        const hexEl = hexOnBoard.el
        const targetX = hexEl.offsetLeft + hexEl.offsetWidth / 2 - pieceSize / 2
        const targetY = hexEl.offsetTop + hexEl.offsetHeight / 2 - pieceSize / 2
        pieceData.el.style.transform = `translate(${targetX}px, ${targetY}px)`
      }

      function createOrUpdateItemPiece(itemData) {
        const hexSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hex-size'))
        const pieceSize = hexSize * 0.7

        if (!itemData.el) {
          itemData.el = document.createElement('div')
          itemData.el.className = 'piece item-piece'
          itemData.el.style.width = `${pieceSize}px`
          itemData.el.style.height = `${pieceSize}px`
          if (itemData.type === 'boots') {
            itemData.el.textContent = 'B'
          } else if (itemData.type === 'cloak') {
            itemData.el.textContent = 'C'
          }
          // スネアトラップキットの表示
          else if (itemData.type === 'snare_trap') {
            itemData.el.textContent = 'S' // アイコンはインベントリと合わせる
          }
          gameBoard.appendChild(itemData.el)
        }

        const hexKey = `${itemData.pos.q},${itemData.pos.r}`
        const hexOnBoard = gameState.grid.get(hexKey)
        if (!hexOnBoard || !hexOnBoard.el) return

        const hexEl = hexOnBoard.el
        const targetX = hexEl.offsetLeft + hexEl.offsetWidth / 2 - pieceSize / 2
        const targetY = hexEl.offsetTop + hexEl.offsetHeight / 2 - pieceSize / 2
        itemData.el.style.transform = `translate(${targetX}px, ${targetY}px)`
      }

      function createOrUpdateTrapPiece(trapData) {
        const hexSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hex-size'))
        const pieceSize = hexSize * 0.7

        if (!trapData.el) {
          trapData.el = document.createElement('div')
          trapData.el.className = 'piece trap-piece' // 新しいCSSクラス
          trapData.el.style.width = `${pieceSize}px`
          trapData.el.style.height = `${pieceSize}px`
          trapData.el.textContent = 'S' // スネアトラップのアイコン
          gameBoard.appendChild(trapData.el)
        }
        const hexKey = `${trapData.pos.q},${trapData.pos.r}`
        const hexOnBoard = gameState.grid.get(hexKey)
        if (!hexOnBoard || !hexOnBoard.el) return

        const hexEl = hexOnBoard.el
        const targetX = hexEl.offsetLeft + hexEl.offsetWidth / 2 - pieceSize / 2
        const targetY = hexEl.offsetTop + hexEl.offsetHeight / 2 - pieceSize / 2
        trapData.el.style.transform = `translate(${targetX}px, ${targetY}px)`
      }

      function onHexClick(q, r) {
        if (!gameState.isPlayerTurn) return
        const targetHex = { q, r }

        if (gameState.isPlacingTrap) {
          const trapType = gameState.isPlacingTrap
          if (canPlaceTrapAt(targetHex, trapType)) {
            placeTrap(targetHex, trapType)
          } else {
            updateMessage('ここにはトラップを設置できません。', 'error')
          }
        } else if (Axial.distance(gameState.player.pos, targetHex) === 1) {
          movePlayer(targetHex)
        } else {
          updateMessage('隣接するマスにのみ移動できます。', 'error')
        }
      }

      // ★メッセージ更新用関数
      function updateMessage(text, type = 'info') {
        messageEl.textContent = text
        // TODO: typeに応じてmessageElのクラスを変更し、スタイルを適用する (例: messageEl.className = `message-area message-${type}`)
      }

      function updateHighlights() {
        gameState.grid.forEach((hex) => {
          if (hex.el) {
            // hex.elが存在するか確認
            hex.el.classList.remove('highlight')
            hex.el.classList.remove('placeable-trap-highlight')

            if (gameState.isPlacingTrap) {
              if (canPlaceTrapAt(hex, gameState.isPlacingTrap)) {
                hex.el.classList.add('placeable-trap-highlight')
              }
            } else if (gameState.isPlayerTurn && Axial.distance(gameState.player.pos, hex) === 1) {
              hex.el.classList.add('highlight')
            }
          }
        })
      }

      function canPlaceTrapAt(hexPos, trapType) {
        if (Axial.distance(gameState.player.pos, hexPos) !== 1) return false // 隣接マスのみ
        const hexKey = `${hexPos.q},${hexPos.r}`
        if (!gameState.grid.has(hexKey)) return false // グリッド外
        if (gameState.mobs.some((m) => m.pos.q === hexPos.q && m.pos.r === hexPos.r)) return false // モブがいる
        if (gameState.itemsOnBoard.some((i) => i.pos.q === hexPos.q && i.pos.r === hexPos.r)) return false // アイテムがある
        if (gameState.trapsOnBoard.some((t) => t.pos.q === hexPos.q && t.pos.r === hexPos.r)) return false // 既にトラップがある
        return true
      }

      function onHexMouseEnter(hexData) {
        if (gameState.isGameOver || !gameState.isPlayerTurn) return
        const mobOnThisHex = gameState.mobs.find((mob) => mob.pos.q === hexData.q && mob.pos.r === hexData.r)
        if (mobOnThisHex) {
          const stats = MOB_STATS[mobOnThisHex.level]
          const detectionRange = stats.detectionRange
          gameState.grid.forEach((hex) => {
            if (
              hex.el &&
              Axial.distance(mobOnThisHex.pos, hex) <= detectionRange &&
              Axial.distance(mobOnThisHex.pos, hex) > 0
            ) {
              hex.el.classList.add('detection-highlight')
            }
          })
        }
      }

      function onHexMouseLeave() {
        if (gameState.isGameOver) return
        clearDetectionHighlights()
      }

      function clearDetectionHighlights() {
        gameState.grid.forEach((hex) => {
          if (hex.el) {
            // hex.elが存在するか確認
            hex.el.classList.remove('detection-highlight')
          }
        })
        if (gameState.isPlayerTurn) updateHighlights()
      }

      function startPlacingTrap(trapType) {
        if (!gameState.isPlayerTurn || gameState.isPlacingTrap) return
        const trapItem = gameState.player.inventory.find((item) => item.type === trapType)
        if (trapItem && trapItem.quantity > 0) {
          gameState.isPlacingTrap = trapType
          updateMessage(`${trapItem.name}を設置する場所を選んでください。`, 'info')
          updateHighlights()
          updateInventoryUI() // ボタンの状態を更新
        }
      }

      function placeTrap(targetPos, trapType) {
        const trapItem = gameState.player.inventory.find((item) => item.type === trapType)
        if (!trapItem || trapItem.quantity <= 0) return

        trapItem.quantity--
        const newTrap = {
          id: `trap-${gameState.nextTrapId++}`,
          pos: { ...targetPos },
          type: trapType,
          el: null,
          turnsLeft: SNARE_TRAP_DURATION, // スネアトラップの場合
          triggered: false,
        }
        gameState.trapsOnBoard.push(newTrap)
        createOrUpdateTrapPiece(newTrap)

        gameState.isPlacingTrap = null
        gameState.player.remainingMovesThisTurn = 0 // 設置は1アクション消費
        updateMessage(`${trapItem.name}を設置しました。モンスターのターン...`, 'info')
        endPlayerTurn()
      }

      function movePlayer(targetPos) {
        gameState.player.pos = targetPos
        createOrUpdatePiece(gameState.player, 'player')

        const itemIndex = gameState.itemsOnBoard.findIndex(
          (item) => item.pos.q === targetPos.q && item.pos.r === targetPos.r
        )
        if (itemIndex !== -1) {
          pickUpItem(itemIndex)
        }

        const mobIndex = gameState.mobs.findIndex((mob) => mob.pos.q === targetPos.q && mob.pos.r === targetPos.r)
        if (mobIndex !== -1) {
          captureMob(mobIndex)
        }

        gameState.player.remainingMovesThisTurn--

        if (gameState.isGameOver) return

        if (gameState.player.remainingMovesThisTurn > 0) {
          updateMessage('続けて移動できます。')
          updateHighlights()
        } else {
          updateMessage('モンスターのターン...')
          gameState.isPlayerTurn = false

          if (gameState.player.cloakTurnsLeft > 0) {
            gameState.player.cloakTurnsLeft--
            if (gameState.player.cloakTurnsLeft === 0) {
              // メッセージはmobsTurn後のメッセージで上書きされるので、ここでは特に表示しない
            }
          }
          updateInventoryUI()
          endPlayerTurn()
        }
      }

      function endPlayerTurn() {
        updateHighlights() // ハイライトをクリア
        clearDetectionHighlights()
        setTimeout(mobsTurn, 500)
      }

      function pickUpItem(itemIndex) {
        const pickedUpItemData = gameState.itemsOnBoard.splice(itemIndex, 1)[0]
        if (pickedUpItemData && pickedUpItemData.el && pickedUpItemData.el.parentNode === gameBoard) {
          gameBoard.removeChild(pickedUpItemData.el)
        }
        if (!pickedUpItemData) return

        const inventorySlot = gameState.player.inventory.find((slot) => slot.type === pickedUpItemData.type)
        if (inventorySlot) {
          inventorySlot.quantity++
          updateMessage(`${inventorySlot.name}を取得！`, 'success')
        } else {
          console.error(`Picked up an item of unknown type: ${pickedUpItemData.type}.`)
          updateMessage(`不明なアイテム (${pickedUpItemData.type}) を取得！`, 'warning')
        }
        updateInventoryUI()
      }

      function captureMob(mobIndex) {
        const capturedMob = gameState.mobs.splice(mobIndex, 1)[0]
        if (capturedMob && capturedMob.el) {
          capturedMob.el.style.transition = 'transform 0.3s ease, opacity 0.3s ease'
          capturedMob.el.style.transform += ' scale(0)'
          capturedMob.el.style.opacity = '0'
          setTimeout(() => {
            if (capturedMob.el.parentNode === gameBoard) {
              gameBoard.removeChild(capturedMob.el)
            }
          }, 300)
        }

        const mobScore = MOB_STATS[capturedMob.level].score
        gameState.score += mobScore
        updateMessage(`LV${capturedMob.level}モンスターを捕獲！ (+${mobScore}スコア)`, 'success')

        updateInfo()
      }

      function getWeightedRandomLevel(currentScore) {
        const weights = []
        let totalWeight = 0

        for (const levelStr in MOB_LEVEL_SPAWN_PARAMS) {
          const level = parseInt(levelStr)
          const params = MOB_LEVEL_SPAWN_PARAMS[level]
          // スコアが低い場合でもscoreMultiplierが負だと魅力度が下がりすぎるのを防ぐため、
          // currentScore * params.scoreMultiplier の結果が params.baseAttractiveness を大きく下回らないように調整
          const calculatedAttractiveness = params.baseAttractiveness + currentScore * params.scoreMultiplier
          const weight = Math.max(1, calculatedAttractiveness) // 最低ウェイトを1とする
          weights.push({ level: level, weight: weight })
          totalWeight += weight
        }

        let randomValue = Math.random() * totalWeight

        for (const item of weights) {
          if (randomValue < item.weight) {
            return item.level
          }
          randomValue -= item.weight
        }
        return weights[weights.length - 1].level // フォールバック (通常は到達しないはず)
      }

      function spawnNewMob(isInitial = false) {
        const occupiedKeys = new Set([`${gameState.player.pos.q},${gameState.player.pos.r}`])
        gameState.mobs.forEach((m) => occupiedKeys.add(`${m.pos.q},${m.pos.r}`))
        gameState.itemsOnBoard.forEach((i) => occupiedKeys.add(`${i.pos.q},${i.pos.r}`))
        gameState.trapsOnBoard.forEach((t) => occupiedKeys.add(`${t.pos.q},${t.pos.r}`)) // トラップのある場所も占有扱い

        let allEmptyHexes = Array.from(gameState.grid.keys()).filter((k) => !occupiedKeys.has(k))

        let candidateLocations = allEmptyHexes.filter((key) => {
          const [q, r] = key.split(',').map(Number)
          return Axial.distance(gameState.player.pos, { q, r }) >= gameState.minSpawnDistance
        })

        if (candidateLocations.length > 0) {
          const furtherFiltered = candidateLocations.filter((key) => {
            const [q, r] = key.split(',').map(Number)
            const newMobPos = { q, r }
            return gameState.mobs.every(
              (existingMob) => Axial.distance(existingMob.pos, newMobPos) >= gameState.minSpawnDistanceFromOtherMobs
            )
          })
          if (furtherFiltered.length > 0) candidateLocations = furtherFiltered
        } else if (allEmptyHexes.length > 0) {
          candidateLocations = allEmptyHexes
        }

        if (candidateLocations.length === 0) return

        const mobLevel = isInitial ? 1 : getWeightedRandomLevel(gameState.score)
        const randomIndex = Math.floor(Math.random() * candidateLocations.length)
        const mobKey = candidateLocations[randomIndex]
        const [q, r] = mobKey.split(',').map(Number)
        const newMob = {
          id: `mob-${gameState.nextMobId++}`,
          pos: { q, r },
          el: null,
          level: mobLevel,
          stunnedTurns: 0, // スタン状態の残りターン
        }
        gameState.mobs.push(newMob)

        if (!isInitial) createOrUpdatePiece(newMob, 'mob')
      }

      function spawnItem() {
        if (Math.random() >= ITEM_SPAWN_CHANCE || gameState.itemsOnBoard.length >= gameState.maxItemsOnBoard) return

        const occupiedKeys = new Set([`${gameState.player.pos.q},${gameState.player.pos.r}`])
        gameState.mobs.forEach((m) => occupiedKeys.add(`${m.pos.q},${m.pos.r}`))
        gameState.itemsOnBoard.forEach((i) => occupiedKeys.add(`${i.pos.q},${i.pos.r}`))
        gameState.trapsOnBoard.forEach((t) => occupiedKeys.add(`${t.pos.q},${t.pos.r}`)) // トラップのある場所も占有扱い

        let allEmptyHexes = Array.from(gameState.grid.keys()).filter((k) => !occupiedKeys.has(k))
        let candidateLocations = allEmptyHexes.filter((key) => {
          const [q, r] = key.split(',').map(Number)
          return Axial.distance(gameState.player.pos, { q, r }) >= gameState.minItemSpawnDistanceFromPlayer
        })

        if (candidateLocations.length === 0 && allEmptyHexes.length > 0) candidateLocations = allEmptyHexes
        if (candidateLocations.length === 0) return

        const randomIndex = Math.floor(Math.random() * candidateLocations.length)
        const itemKey = candidateLocations[randomIndex]
        const [q, r] = itemKey.split(',').map(Number)
        const newItem = {
          id: `item-${gameState.nextItemId++}`,
          pos: { q, r },
          el: null,
          type: ITEM_TYPES[Math.floor(Math.random() * ITEM_TYPES.length)],
        }
        gameState.itemsOnBoard.push(newItem)
        createOrUpdateItemPiece(newItem)
      }

      function useBootsItem() {
        if (
          gameState.isGameOver ||
          !gameState.isPlayerTurn ||
          gameState.player.remainingMovesThisTurn > 1 ||
          gameState.isPlacingTrap
        )
          return
        const boots = gameState.player.inventory.find((item) => item.type === 'boots')
        if (boots && boots.quantity > 0) {
          boots.quantity--
          gameState.player.remainingMovesThisTurn = 2
          updateMessage(`${boots.name}を使用！2回移動できます。`, 'info')
          updateInventoryUI()
        }
      }

      function useCloakItem() {
        if (
          gameState.isGameOver ||
          !gameState.isPlayerTurn ||
          gameState.player.cloakTurnsLeft > 0 ||
          gameState.isPlacingTrap
        )
          return
        const cloak = gameState.player.inventory.find((item) => item.type === 'cloak')
        if (cloak && cloak.quantity > 0) {
          cloak.quantity--
          gameState.player.cloakTurnsLeft = CLOAK_DURATION
          updateMessage(`${cloak.name}を使用！${CLOAK_DURATION}ターンの間、見つかりにくくなります。`, 'info')
          updateInventoryUI()
        }
      }

      function useSnareTrapItem() {
        if (gameState.isGameOver || !gameState.isPlayerTurn) return
        if (gameState.isPlacingTrap) {
          // 設置モード中に再度押されたらキャンセル
          gameState.isPlacingTrap = null
          updateMessage('トラップ設置をキャンセルしました。', 'info')
          updateHighlights()
          updateInventoryUI()
        } else {
          startPlacingTrap('snare_trap')
        }
      }

      function mobsTurn() {
        if (gameState.isGameOver) return
        let isGameOver = false
        let mobMessages = [] // モブの行動に関するメッセージを一時的に保存

        gameState.mobs.forEach((mob) => {
          const stats = MOB_STATS[mob.level]
          const distanceToPlayer = Axial.distance(mob.pos, gameState.player.pos)

          if (mob.stunnedTurns > 0) {
            const wasStunned = true
            mob.stunnedTurns--
            if (mob.stunnedTurns === 0 && wasStunned) {
              mobMessages.push(`LV${mob.level}モンスターがスタンから回復した！`)
            } else if (mob.stunnedTurns > 0) {
              mobMessages.push(`LV${mob.level}モンスターはスネアトラップで動けない (残り${mob.stunnedTurns}ターン)。`)
            }
            createOrUpdatePiece(mob, 'mob') // スタン状態の更新を視覚に反映
            return // このモブは行動不能
          }
          let bestMove = mob.pos
          let canDetectPlayer = true
          if (gameState.player.cloakTurnsLeft > 0 && Math.random() < CLOAK_EVASION_CHANCE) {
            canDetectPlayer = false
          }
          if (canDetectPlayer && distanceToPlayer <= stats.detectionRange) {
            let minDistance = distanceToPlayer
            let bestMoves = [mob.pos] // 最適な移動先候補を配列で保持
            const neighbors = Axial.neighbors(mob.pos)
            for (const neighbor of neighbors) {
              if (
                gameState.grid.has(`${neighbor.q},${neighbor.r}`) &&
                !gameState.mobs.some((m) => m.pos.q === neighbor.q && m.pos.r === neighbor.r && m.id !== mob.id) // 他のモブがいない
              ) {
                const d = Axial.distance(neighbor, gameState.player.pos)
                if (d < minDistance) {
                  // より近いマスが見つかった場合
                  minDistance = d
                  bestMoves = [neighbor] // 候補をリセットして新しい最適解を追加
                } else if (d === minDistance && d < distanceToPlayer) {
                  // 同じ距離でより近いマスが見つかった場合
                  bestMoves.push(neighbor) // 候補に追加
                }
              }
            }
            if (bestMoves.length > 1 && bestMoves[0] === mob.pos && minDistance === distanceToPlayer) {
              // 移動先がない場合（現在地が唯一の最適解）は現在地を維持
              bestMove = mob.pos
            } else if (bestMoves.length > 0 && bestMoves[0] !== mob.pos) {
              // 移動可能な最適解がある場合
              bestMove = bestMoves[Math.floor(Math.random() * bestMoves.length)] // 候補からランダムに選択
            }
          } else {
            const neighbors = Axial.neighbors(mob.pos)
            const validMoves = neighbors.filter(
              (n) =>
                gameState.grid.has(`${n.q},${n.r}`) &&
                !gameState.mobs.some((m) => m.pos.q === n.q && m.pos.r === n.r && m.id !== mob.id)
            )
            if (validMoves.length > 0) {
              bestMove = validMoves[Math.floor(Math.random() * validMoves.length)]
            }
          }

          // まずモブを移動させる
          const previousPos = { ...mob.pos }
          mob.pos = bestMove

          // 移動後に、現在の位置にトラップがあるか確認
          const trapIndexOnCurrentHex = gameState.trapsOnBoard.findIndex(
            (trap) =>
              trap.pos.q === mob.pos.q && trap.pos.r === mob.pos.r && !trap.triggered && trap.type === 'snare_trap'
          )

          if (trapIndexOnCurrentHex !== -1 && (mob.pos.q !== previousPos.q || mob.pos.r !== previousPos.r)) {
            // 実際に移動した場合のみトラップ作動
            const trap = gameState.trapsOnBoard[trapIndexOnCurrentHex]
            trap.triggered = true // 作動済みにする
            mob.stunnedTurns = SNARE_TRAP_STUN_TURNS
            mobMessages.push(
              `LV${mob.level}モンスターが (${mob.pos.q},${mob.pos.r}) のスネアトラップにかかり動けなくなった！ (${SNARE_TRAP_STUN_TURNS}ターン行動不能)`
            )
            // トラップは作動後すぐに消滅させる
            if (trap.el && trap.el.parentNode === gameBoard) {
              gameBoard.removeChild(trap.el)
            }
            gameState.trapsOnBoard.splice(trapIndexOnCurrentHex, 1)
          }

          createOrUpdatePiece(mob, 'mob') // 移動とスタン状態を視覚に反映

          if (Axial.distance(mob.pos, gameState.player.pos) === 0) isGameOver = true
        })

        if (isGameOver) {
          setTimeout(endGame, 300)
          updateInventoryUI() // ゲームオーバー時にボタンを無効化
          return
        }

        if (!gameState.isGameOver) {
          spawnItem()
          // ★毎ターン終了時に確率で新しいモンスターをスポーン
          const mobCount = gameState.mobs.length
          const maxCapacity = gameState.maxMobCapacity || Math.max(5, Math.floor(gameState.gridRadius * 2)) // マップサイズに応じた最大モブ数
          const occupancyRate = Math.min(1.0, mobCount / maxCapacity) // 0.0 ~ 1.0

          const exponent = 2 // この値を調整することで変化の度合いを変える (例: 1, 1.5, 2, 3)
          // 占有率が低いほどスポーン確率が高くなるように調整
          // (1 - occupancyRate) が0に近いほど確率が低く、1に近いほど確率が高い
          let dynamicSpawnChance = MOB_SPAWN_CHANCE_PER_TURN * Math.pow(1 - occupancyRate, exponent)

          if (Math.random() < Math.max(0.05, Math.min(0.95, dynamicSpawnChance))) {
            // 最低5%, 最高95%の確率
            spawnNewMob()
          }

          // トラップの持続時間処理
          let trapMessages = []
          gameState.trapsOnBoard = gameState.trapsOnBoard.filter((trap) => {
            if (trap.triggered) return false // 作動済みのトラップはここで除去（mobsTurn内で除去済みだが念のため）
            trap.turnsLeft--
            if (trap.turnsLeft <= 0) {
              if (trap.el && trap.el.parentNode === gameBoard) {
                gameBoard.removeChild(trap.el)
              }
              trapMessages.push(`${trap.type === 'snare_trap' ? 'スネアトラップ' : 'トラップ'}の効果が切れた。`)
              return false // 配列から削除
            }
            return true
          })

          gameState.turn++
          gameState.isPlayerTurn = true
          gameState.player.remainingMovesThisTurn = 1
          updateInfo()
          updateInventoryUI()
          updateHighlights()
          // clearDetectionHighlights() // updateHighlights内で処理される

          let turnEndMessage = ''
          if (mobMessages.length > 0) {
            turnEndMessage += mobMessages.join(' ') + ' '
          }
          if (trapMessages.length > 0) {
            turnEndMessage += trapMessages.join(' ') + ' '
          }

          if (gameState.player.cloakTurnsLeft > 0) {
            turnEndMessage += `あなたのターンです。(隠れ蓑効果: 残り${gameState.player.cloakTurnsLeft}ターン)`
          } else {
            turnEndMessage += 'あなたのターンです。移動したいマスを選択してください。'
          }
          updateMessage(turnEndMessage.trim())
        }
      }

      function endGame() {
        gameState.isPlayerTurn = false
        gameState.isGameOver = true
        updateMessage(`ゲームオーバー！最終スコア: ${gameState.score}`, 'gameover')
        gameState.grid.forEach((hex) => {
          if (hex.el) {
            // hex.elが存在するか確認
            hex.el.classList.remove('highlight')
            hex.el.classList.remove('detection-highlight')
            hex.el.classList.remove('placeable-trap-highlight')
          }
        })
        updateInventoryUI() // ボタンを無効化
      }

      function updateInfo() {
        scoreEl.textContent = gameState.score
        turnEl.textContent = gameState.turn
      }

      function updateInventoryUI() {
        inventoryArea.innerHTML = ''
        gameState.player.inventory.forEach((item) => {
          if (item) {
            const itemDiv = document.createElement('div')
            itemDiv.className = 'inventory-item'

            const iconSpan = document.createElement('span')
            iconSpan.className = 'item-icon'
            iconSpan.textContent = item.icon || ''
            itemDiv.appendChild(iconSpan)

            const textSpan = document.createElement('span')
            let itemText = `${item.name}: ${item.quantity}個`
            if (item.type === 'cloak' && gameState.player.cloakTurnsLeft > 0) {
              itemText += ` (効果中: 残り${gameState.player.cloakTurnsLeft}ターン)`
            }
            textSpan.textContent = itemText
            itemDiv.appendChild(textSpan)
            inventoryArea.appendChild(itemDiv)

            if (item.type === 'boots') {
              const useButton = document.createElement('button')
              useButton.textContent = '使用'
              useButton.title = `${item.name}を使用する`
              useButton.onclick = useBootsItem
              inventoryArea.appendChild(useButton)
              if (
                gameState.isGameOver ||
                !gameState.isPlayerTurn ||
                gameState.player.remainingMovesThisTurn > 1 ||
                item.quantity === 0 ||
                gameState.isPlacingTrap
              ) {
                useButton.disabled = true
              }
            } else if (item.type === 'cloak') {
              const useButton = document.createElement('button')
              useButton.textContent = '使用'
              useButton.title = `${item.name}を使用する`
              useButton.onclick = useCloakItem
              inventoryArea.appendChild(useButton)
              if (
                gameState.isGameOver ||
                !gameState.isPlayerTurn ||
                gameState.player.cloakTurnsLeft > 0 ||
                item.quantity === 0 ||
                gameState.isPlacingTrap
              ) {
                useButton.disabled = true
              }
            } else if (item.type === 'snare_trap') {
              const useButton = document.createElement('button')
              useButton.textContent = gameState.isPlacingTrap === 'snare_trap' ? 'キャンセル' : '設置'
              useButton.title =
                gameState.isPlacingTrap === 'snare_trap' ? 'スネアトラップの設置をキャンセル' : `${item.name}を設置する`
              useButton.onclick = useSnareTrapItem
              inventoryArea.appendChild(useButton)
              if (gameState.isGameOver || !gameState.isPlayerTurn || item.quantity === 0) {
                if (gameState.isPlacingTrap !== 'snare_trap') {
                  // キャンセルボタンは有効にする
                  useButton.disabled = true
                }
              }
            }
          }
        })
      }

      restartButton.addEventListener('click', () => {
        const selectedRadius = parseInt(mapSizeSelector.value)
        // DOMの表示更新が完了した後にinitGameを呼び出す (タイミング問題を避けるため)
        requestAnimationFrame(() => initGame(selectedRadius))
      })

      // 初期ゲーム開始
      requestAnimationFrame(() => initGame(parseInt(mapSizeSelector.value))) // リセット時と同じ呼び出し方にする
    </script>
  </body>
</html>
