<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>チェイス＆ハイド</title>
    <style>
      :root {
        --hex-size: 40px;
        --board-bg: #f0f0f0;
        --hex-bg: #ffffff;
        --player-color: #3498db;
        /* mobの色はJSで設定 */
        --highlight-color: rgba(52, 152, 219, 0.3);
        --font-family: 'Inter', 'Noto Sans JP', sans-serif;
      }

      body {
        font-family: var(--font-family);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        margin: 0;
        padding: 5px 0;
        background-color: #e9ebee;
        color: #333;
      }

      .game-container {
        display: flex; /* 最初から表示 */
        flex-direction: column;
        align-items: center;
        gap: 10px;
        padding: 10px;
        background-color: white;
        border-radius: 16px;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
        width: 95%;
        max-width: 1200px;
        /* min-height はJSで調整 */
      }

      .game-info {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-around;
        width: 100%;
        gap: 10px;
        margin-bottom: 0;
        font-size: 1.2em;
        font-weight: bold;
        text-align: center;
      }

      .info-box {
        background-color: #f8f9fa;
        padding: 10px 20px;
        border-radius: 12px;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
      }

      #game-board {
        position: relative;
        background-color: var(--board-bg);
        border-radius: 12px;
        overflow: hidden; /* はみ出たヘクスを隠す */
        /* transform: scale() はJSで動的に設定 */
        margin: 0 auto; /* 中央寄せにしつつ、上下マージンは0 */
      }

      .hex {
        position: absolute;
        width: calc(var(--hex-size) * 2);
        height: calc(var(--hex-size) * 2 * 0.866);
        background-color: var(--hex-bg);
        clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
        transition: background-color 0.3s ease, transform 0.2s ease;
        cursor: pointer;
        z-index: 1;
      }

      .hex:hover {
        transform: scale(1.05);
        z-index: 2;
      }

      .hex.highlight {
        background-color: var(--highlight-color);
      }

      .hex.detection-highlight {
        background-color: rgba(255, 165, 0, 0.3);
      }

      .item-piece {
        background-color: #2ecc71;
        box-shadow: 0 0 8px #2ecc71;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        color: white;
        font-size: calc(var(--hex-size) * 0.5);
        pointer-events: none;
        /* z-index は piece 共通で設定し、mobで上書き */
      }

      .piece {
        position: absolute;
        top: 0;
        left: 0;
        border-radius: 50%;
        transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        z-index: 5; /* 基本のz-index */
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .player {
        background-color: var(--player-color);
        box-shadow: 0 0 10px var(--player-color);
        pointer-events: none;
      }

      .mob {
        pointer-events: none;
        z-index: 6; /* アイテムより手前に表示 */
      }

      .mob-level {
        color: white;
        font-size: calc(var(--hex-size) * 0.4);
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }

      .message-area {
        height: auto;
        line-height: 1.2;
        font-size: 1em;
        color: #555;
        font-weight: 500;
        text-align: center;
      }

      button {
        background-color: var(--player-color);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 1em;
        cursor: pointer;
        transition: background-color 0.2s, transform 0.2s;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      }

      button:hover {
        background-color: #2980b9;
        transform: translateY(-2px);
      }

      button:disabled {
        background-color: #bdc3c7;
        color: #7f8c8d;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
      }
      .inventory-area {
        display: flex;
        gap: 15px;
        align-items: center;
        margin-top: 5px;
        padding: 10px;
        background-color: #f0f0f0;
        border-radius: 8px;
      }
      .inventory-item {
        font-weight: 500;
      }
      .item-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: calc(var(--hex-size) * 0.6);
        height: calc(var(--hex-size) * 0.6);
        background-color: #2ecc71;
        color: white;
        font-weight: bold;
        border-radius: 50%;
        font-size: calc(var(--hex-size) * 0.4);
        margin-right: 5px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <style>
        h1 {
          margin-top: 0;
          margin-bottom: 5px;
        }
        .game-controls { display: flex; align-items: center; gap: 15px; margin-top: 10px; }
      </style>
      <h1>チェイス＆ハイド</h1>
      <div class="game-info">
        <div class="info-box">スコア: <span id="score">0</span></div>
        <div class="info-box">ターン: <span id="turn">1</span></div>
      </div>

      <div id="game-board"></div>

      <div id="message-area" class="message-area">あなたのターンです。</div>

      <div id="inventory-area" class="inventory-area"></div>

      <div class="game-controls">
        <button id="restart-button">ゲームをリセット</button>
        <div>
            <label for="map-size-selector">マップサイズ (半径): </label>
            <select id="map-size-selector">
                <option value="4">小 (4)</option>
                <option value="5" selected>中 (5)</option>
                <option value="6">大 (6)</option>
                <option value="7">特大 (7)</option>
            </select>
        </div>
      </div>
    </div>

    <script>
      // --- ゲーム設定 (グローバル定数からgameStateプロパティへ移行) ---
      const ITEM_SPAWN_CHANCE = 0.1
      const ITEM_TYPES = ['boots', 'cloak']
      const CLOAK_DURATION = 3
      const CLOAK_EVASION_CHANCE = 0.7
      const MOB_SPAWN_CHANCE_PER_TURN = 1.0 // 毎ターン新しいモンスターが出現する確率 (90%)

      const MOB_STATS = {
        1: { detectionRange: 2, color: '#f1c40f', score: 5 },
        2: { detectionRange: 3, color: '#e67e22', score: 10 },
        3: { detectionRange: 4, color: '#e74c3c', score: 20 },
        4: { detectionRange: 5, color: '#c0392b', score: 40 },
        5: { detectionRange: 6, color: '#922b21', score: 75 },
      }

      // --- DOM要素 ---
      const gameBoard = document.getElementById('game-board')
      const scoreEl = document.getElementById('score')
      const turnEl = document.getElementById('turn')
      const messageEl = document.getElementById('message-area')
      const restartButton = document.getElementById('restart-button')
      const inventoryArea = document.getElementById('inventory-area')

      const gameContainerEl = document.querySelector('.game-container')
      const mapSizeSelector = document.getElementById('map-size-selector')

      let gameState = {}

      const Axial = {
        add: (a, b) => ({ q: a.q + b.q, r: a.r + b.r }),
        subtract: (a, b) => ({ q: a.q - b.q, r: a.r - b.r }),
        distance: (a, b) => {
          const vec = Axial.subtract(a, b)
          return (Math.abs(vec.q) + Math.abs(vec.q + vec.r) + Math.abs(vec.r)) / 2
        },
        neighbors: (hex) => [
          { q: hex.q + 1, r: hex.r },
          { q: hex.q - 1, r: hex.r },
          { q: hex.q, r: hex.r + 1 },
          { q: hex.q, r: hex.r - 1 },
          { q: hex.q + 1, r: hex.r - 1 },
          { q: hex.q - 1, r: hex.r + 1 },
        ],
      }

      function initGame(selectedRadius) {
        gameState = {
          gridRadius: selectedRadius,
          grid: new Map(),
          player: { pos: { q: 0, r: 0 }, el: null },
          mobs: [],
          itemsOnBoard: [],
          score: 0,
          turn: 1,
          isPlayerTurn: true,
          isGameOver: false,
        }
        gameState.player.inventory = [
          { type: 'boots', quantity: 0, name: 'ダッシュブーツ', icon: 'B' },
          { type: 'cloak', quantity: 0, name: '隠れ蓑', icon: 'C' },
        ]
        gameState.player.remainingMovesThisTurn = 1
        gameState.player.cloakTurnsLeft = 0

        // マップサイズに応じたバランスパラメータの計算
        const baseRadiusForBalance = 5
        const radiusRatio = Math.max(0.5, selectedRadius / baseRadiusForBalance)

        gameState.initialMobs = Math.max(2, Math.floor(4 * radiusRatio))
        gameState.minSpawnDistance = Math.max(2, Math.floor(3 * radiusRatio))
        gameState.minSpawnDistanceFromOtherMobs = Math.max(1, Math.floor(2 * radiusRatio))
        gameState.maxItemsOnBoard = Math.max(1, Math.floor(3 * radiusRatio))
        gameState.minItemSpawnDistanceFromPlayer = Math.max(1, Math.floor(2 * radiusRatio))

        // ヘクスサイズの決定 (clientWidthに依存しないように変更)
        // マップ半径に応じてヘクスサイズを段階的に設定
        let newHexSize = 40; // デフォルト
        if (selectedRadius >= 7) { // 半径7以上の場合
          newHexSize = 30;
        } else if (selectedRadius >= 6) { // 半径6の場合
          newHexSize = 35;
        }
        // 最小ヘクスサイズは15pxとする
        newHexSize = Math.max(15, newHexSize);
        document.documentElement.style.setProperty('--hex-size', `${newHexSize}px`)

        for (let q = -gameState.gridRadius; q <= gameState.gridRadius; q++) {
          for (let r = -gameState.gridRadius; r <= gameState.gridRadius; r++) {
            if (Math.abs(q + r) > gameState.gridRadius) continue
            gameState.grid.set(`${q},${r}`, { q, r, el: null })
          }
        }

        for (let i = 0; i < gameState.initialMobs; i++) {
          spawnNewMob(true)
        }

        // --hex-size の設定がDOMに反映された後に盤面を描画する
        function drawBoardWhenReady() {
            const currentHexSizeStyle = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hex-size'));
            // 設定したnewHexSizeと、実際にgetComputedStyleで取得できる値が一致するか確認
            if (Math.abs(currentHexSizeStyle - newHexSize) < 0.1) { // 浮動小数点数の比較のため、わずかな誤差を許容
                drawBoard();
                updateInfo();
                updateInventoryUI();
                updateMessage('あなたのターンです。移動したいマスを選択してください。');
            } else {
                // まだスタイルが反映されていない場合、次のフレームで再試行
                requestAnimationFrame(drawBoardWhenReady);
            }
        }
        // drawBoardWhenReady を最初のフレームで呼び出し開始
        // これにより、--hex-size の設定が確実にDOMに反映されるのを待つ
        requestAnimationFrame(drawBoardWhenReady);
      }

      function drawBoard() {
        gameBoard.innerHTML = ''
        const hexSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hex-size'))
        const hexFullHeight = hexSize * Math.sqrt(3);
        const hexFullWidth = hexSize * 2;

        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        const hexPositions = []; // Store calculated positions

        // 1. Calculate all hex positions relative to a virtual (0,0) center
        //    and determine the bounding box of all hexes.
        gameState.grid.forEach((hexData) => {
            const centerX = hexSize * 1.5 * hexData.q;
            const centerY = hexFullHeight * (hexData.r + hexData.q / 2);
            hexPositions.push({ hexData, centerX, centerY });

            minX = Math.min(minX, centerX - hexSize); // Left edge of hex
            maxX = Math.max(maxX, centerX + hexSize); // Right edge of hex
            minY = Math.min(minY, centerY - hexFullHeight / 2); // Top edge of hex
            maxY = Math.max(maxY, centerY + hexFullHeight / 2); // Bottom edge of hex
        });

        // 2. Determine the actual width and height of the game board
        //    by adding padding to the bounding box.
        const boardContentWidth = maxX - minX;
        const boardContentHeight = maxY - minY;
        const boardPadding = hexSize * 4; // グレーの枠の余白をさらに大幅に増やす (ヘクスサイズの4倍)

        const boardWidth = boardContentWidth + boardPadding * 2;
        const boardHeight = boardContentHeight + boardPadding * 2;

        gameBoard.style.width = `${boardWidth}px`;
        gameBoard.style.height = `${boardHeight}px`;

        // 3. Position each hex absolutely within the game board.
        //    The offset is (centerX - minX + boardPadding - hexSize)
        //    (centerX - minX) gives position relative to the leftmost point of hex content.
        //    + boardPadding shifts it by the padding amount.
        //    - hexSize (or -hexFullHeight/2) adjusts from center to top-left for absolute positioning.
        hexPositions.forEach(({ hexData, centerX, centerY }) => {
            const hexEl = document.createElement('div');
            hexEl.className = 'hex';
            hexEl.style.left = `${centerX - minX + boardPadding - hexSize}px`;
            hexEl.style.top = `${centerY - minY + boardPadding - hexFullHeight / 2}px`;

            hexEl.dataset.q = hexData.q;
            hexEl.dataset.r = hexData.r;

            hexEl.addEventListener('click', () => onHexClick(hexData.q, hexData.r));
            hexEl.addEventListener('mouseenter', () => onHexMouseEnter(hexData));
            hexEl.addEventListener('mouseleave', () => onHexMouseLeave());

            hexData.el = hexEl;
            gameBoard.appendChild(hexEl);
        });

        const gameInfoHeight = document.querySelector('.game-info').offsetHeight
        const messageAreaHeight = messageEl.offsetHeight
        const inventoryAreaHeight = inventoryArea.offsetHeight
        const restartButtonHeight = restartButton.offsetHeight
        const containerGap = parseFloat(getComputedStyle(gameContainerEl).gap) || 10 // gapのデフォルト値を10pxとする
        const containerPaddingVertical =
          parseFloat(getComputedStyle(gameContainerEl).paddingTop) +
          parseFloat(getComputedStyle(gameContainerEl).paddingBottom);

        gameContainerEl.style.height = `${
          boardHeight +
          gameInfoHeight +
          messageAreaHeight +
          inventoryAreaHeight +
          restartButtonHeight +
          containerGap * 4 +
          containerPaddingVertical
        }px`

        createOrUpdatePiece(gameState.player, 'player')
        gameState.mobs.forEach((mob) => createOrUpdatePiece(mob, 'mob'))
        gameState.itemsOnBoard.forEach((item) => createOrUpdateItemPiece(item))
        highlightValidMoves()
      }

      function createOrUpdatePiece(pieceData, type) {
        const hexSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hex-size'))
        const pieceSize = hexSize * 0.8

        if (!pieceData.el) {
          pieceData.el = document.createElement('div')
          pieceData.el.className = `piece ${type}`
          pieceData.el.style.width = `${pieceSize}px`
          pieceData.el.style.height = `${pieceSize}px`
          gameBoard.appendChild(pieceData.el)
        }

        if (type === 'mob') {
          const stats = MOB_STATS[pieceData.level]
          pieceData.el.style.backgroundColor = stats.color

          let levelEl = pieceData.el.querySelector('.mob-level')
          if (!levelEl) {
            levelEl = document.createElement('span')
            levelEl.className = 'mob-level'
            pieceData.el.appendChild(levelEl)
          }
          levelEl.textContent = pieceData.level
        }

        const hexKey = `${pieceData.pos.q},${pieceData.pos.r}`
        const hexOnBoard = gameState.grid.get(hexKey)
        if (!hexOnBoard || !hexOnBoard.el) return

        const hexEl = hexOnBoard.el
        const targetX = hexEl.offsetLeft + hexEl.offsetWidth / 2 - pieceSize / 2
        const targetY = hexEl.offsetTop + hexEl.offsetHeight / 2 - pieceSize / 2
        pieceData.el.style.transform = `translate(${targetX}px, ${targetY}px)`
      }

      function createOrUpdateItemPiece(itemData) {
        const hexSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hex-size'))
        const pieceSize = hexSize * 0.7

        if (!itemData.el) {
          itemData.el = document.createElement('div')
          itemData.el.className = 'piece item-piece'
          itemData.el.style.width = `${pieceSize}px`
          itemData.el.style.height = `${pieceSize}px`
          if (itemData.type === 'boots') {
            itemData.el.textContent = 'B'
          } else if (itemData.type === 'cloak') {
            itemData.el.textContent = 'C'
          }
          gameBoard.appendChild(itemData.el)
        }

        const hexKey = `${itemData.pos.q},${itemData.pos.r}`
        const hexOnBoard = gameState.grid.get(hexKey)
        if (!hexOnBoard || !hexOnBoard.el) return

        const hexEl = hexOnBoard.el
        const targetX = hexEl.offsetLeft + hexEl.offsetWidth / 2 - pieceSize / 2
        const targetY = hexEl.offsetTop + hexEl.offsetHeight / 2 - pieceSize / 2
        itemData.el.style.transform = `translate(${targetX}px, ${targetY}px)`
      }

      function onHexClick(q, r) {
        if (!gameState.isPlayerTurn) return
        const targetHex = { q, r }
        if (Axial.distance(gameState.player.pos, targetHex) === 1) {
          movePlayer(targetHex)
        } else {
          updateMessage('隣接するマスにのみ移動できます。', 'error');
        }
      }

      // ★メッセージ更新用関数
      function updateMessage(text, type = 'info') {
        messageEl.textContent = text;
        // TODO: typeに応じてmessageElのクラスを変更し、スタイルを適用する (例: messageEl.className = `message-area message-${type}`)
      }
      function highlightValidMoves() {
        gameState.grid.forEach((hex) => {
          if (hex.el) {
            // hex.elが存在するか確認
            hex.el.classList.remove('highlight')
            if (gameState.isPlayerTurn && Axial.distance(gameState.player.pos, hex) === 1) {
              hex.el.classList.add('highlight')
            }
          }
        })
      }

      function onHexMouseEnter(hexData) {
        if (gameState.isGameOver || !gameState.isPlayerTurn) return
        const mobOnThisHex = gameState.mobs.find((mob) => mob.pos.q === hexData.q && mob.pos.r === hexData.r)
        if (mobOnThisHex) {
          const stats = MOB_STATS[mobOnThisHex.level]
          const detectionRange = stats.detectionRange
          gameState.grid.forEach((hex) => {
            if (
              hex.el &&
              Axial.distance(mobOnThisHex.pos, hex) <= detectionRange &&
              Axial.distance(mobOnThisHex.pos, hex) > 0
            ) {
              hex.el.classList.add('detection-highlight')
            }
          })
        }
      }

      function onHexMouseLeave() {
        if (gameState.isGameOver) return
        clearDetectionHighlights()
      }

      function clearDetectionHighlights() {
        gameState.grid.forEach((hex) => {
          if (hex.el) {
            // hex.elが存在するか確認
            hex.el.classList.remove('detection-highlight')
          }
        })
        if (gameState.isPlayerTurn) highlightValidMoves()
      }

      function movePlayer(targetPos) {
        gameState.player.pos = targetPos
        createOrUpdatePiece(gameState.player, 'player')

        const itemIndex = gameState.itemsOnBoard.findIndex(
          (item) => item.pos.q === targetPos.q && item.pos.r === targetPos.r
        )
        if (itemIndex !== -1) {
          pickUpItem(itemIndex)
        }

        const mobIndex = gameState.mobs.findIndex((mob) => mob.pos.q === targetPos.q && mob.pos.r === targetPos.r)
        if (mobIndex !== -1) {
          captureMob(mobIndex)
        }

        gameState.player.remainingMovesThisTurn--

        if (gameState.isGameOver) return

        if (gameState.player.remainingMovesThisTurn > 0) {
          updateMessage('続けて移動できます。');
          gameState.isPlayerTurn = true
          highlightValidMoves()
          clearDetectionHighlights()
        } else {
          updateMessage('モンスターのターン...');
          gameState.isPlayerTurn = false
          highlightValidMoves()
          clearDetectionHighlights()

          if (gameState.player.cloakTurnsLeft > 0) {
            gameState.player.cloakTurnsLeft--
            if (gameState.player.cloakTurnsLeft === 0) {
              // メッセージはmobsTurn後のメッセージで上書きされるので、ここでは特に表示しない
            }
          }
          updateInventoryUI()
          setTimeout(mobsTurn, 500)
        }
      }

      function pickUpItem(itemIndex) {
        const pickedUpItemData = gameState.itemsOnBoard.splice(itemIndex, 1)[0]
        if (pickedUpItemData && pickedUpItemData.el && pickedUpItemData.el.parentNode === gameBoard) {
          gameBoard.removeChild(pickedUpItemData.el)
        }
        if (!pickedUpItemData) return

        const inventorySlot = gameState.player.inventory.find((slot) => slot.type === pickedUpItemData.type)
        if (inventorySlot) {
          inventorySlot.quantity++
          updateMessage(`${inventorySlot.name}を取得！`, 'success');
        } else {
          console.error(`Picked up an item of unknown type: ${pickedUpItemData.type}.`)
          updateMessage(`不明なアイテム (${pickedUpItemData.type}) を取得！`, 'warning');
        }
        updateInventoryUI()
      }

      function captureMob(mobIndex) {
        const capturedMob = gameState.mobs.splice(mobIndex, 1)[0]
        if (capturedMob && capturedMob.el) {
          capturedMob.el.style.transition = 'transform 0.3s ease, opacity 0.3s ease'
          capturedMob.el.style.transform += ' scale(0)'
          capturedMob.el.style.opacity = '0'
          setTimeout(() => {
            if (capturedMob.el.parentNode === gameBoard) {
              gameBoard.removeChild(capturedMob.el)
            }
          }, 300)
        }

        const mobScore = MOB_STATS[capturedMob.level].score
        gameState.score += mobScore
        updateMessage(`LV${capturedMob.level}モンスターを捕獲！ (+${mobScore}スコア)`, 'success');

        updateInfo()
      }

      function getMobLevelByScore() {
        const score = gameState.score
        const rand = Math.random()
        if (score <= 30) {
          if (rand < 0.9) return 1
          return 2
        } else if (score <= 80) {
          if (rand < 0.4) return 1
          if (rand < 0.9) return 2
          return 3
        } else if (score <= 150) {
          if (rand < 0.1) return 1
          if (rand < 0.5) return 2
          if (rand < 0.9) return 3
          return 4
        } else if (score <= 250) {
          if (rand < 0.2) return 3
          if (rand < 0.6) return 4
          return 5
        } else {
          if (rand < 0.4) return 4
          return 5
        }
      }

      function spawnNewMob(isInitial = false) {
        const occupiedKeys = new Set([`${gameState.player.pos.q},${gameState.player.pos.r}`])
        gameState.mobs.forEach((m) => occupiedKeys.add(`${m.pos.q},${m.pos.r}`))
        let allEmptyHexes = Array.from(gameState.grid.keys()).filter((k) => !occupiedKeys.has(k))

        let candidateLocations = allEmptyHexes.filter((key) => {
          const [q, r] = key.split(',').map(Number)
          return Axial.distance(gameState.player.pos, { q, r }) >= gameState.minSpawnDistance
        })

        if (candidateLocations.length > 0) {
          const furtherFiltered = candidateLocations.filter((key) => {
            const [q, r] = key.split(',').map(Number)
            const newMobPos = { q, r }
            return gameState.mobs.every(
              (existingMob) => Axial.distance(existingMob.pos, newMobPos) >= gameState.minSpawnDistanceFromOtherMobs
            )
          })
          if (furtherFiltered.length > 0) candidateLocations = furtherFiltered
        } else if (allEmptyHexes.length > 0) {
          candidateLocations = allEmptyHexes
        }

        if (candidateLocations.length === 0) return

        const mobLevel = isInitial ? 1 : getMobLevelByScore()
        const randomIndex = Math.floor(Math.random() * candidateLocations.length)
        const mobKey = candidateLocations[randomIndex]
        const [q, r] = mobKey.split(',').map(Number)
        const newMob = {
          id: `mob-${Date.now()}`,
          pos: { q, r },
          el: null,
          level: mobLevel,
        }
        gameState.mobs.push(newMob)

        if (!isInitial) createOrUpdatePiece(newMob, 'mob')
      }

      function spawnItem() {
        if (Math.random() >= ITEM_SPAWN_CHANCE || gameState.itemsOnBoard.length >= gameState.maxItemsOnBoard) return

        const occupiedKeys = new Set([`${gameState.player.pos.q},${gameState.player.pos.r}`])
        gameState.mobs.forEach((m) => occupiedKeys.add(`${m.pos.q},${m.pos.r}`))
        gameState.itemsOnBoard.forEach((i) => occupiedKeys.add(`${i.pos.q},${i.pos.r}`))

        let allEmptyHexes = Array.from(gameState.grid.keys()).filter((k) => !occupiedKeys.has(k))
        let candidateLocations = allEmptyHexes.filter((key) => {
          const [q, r] = key.split(',').map(Number)
          return Axial.distance(gameState.player.pos, { q, r }) >= gameState.minItemSpawnDistanceFromPlayer
        })

        if (candidateLocations.length === 0 && allEmptyHexes.length > 0) candidateLocations = allEmptyHexes
        if (candidateLocations.length === 0) return

        const randomIndex = Math.floor(Math.random() * candidateLocations.length)
        const itemKey = candidateLocations[randomIndex]
        const [q, r] = itemKey.split(',').map(Number)
        const newItem = {
          id: `item-${Date.now()}`,
          pos: { q, r },
          el: null,
          type: ITEM_TYPES[Math.floor(Math.random() * ITEM_TYPES.length)],
        }
        gameState.itemsOnBoard.push(newItem)
        createOrUpdateItemPiece(newItem)
      }

      function useBootsItem() {
        if (gameState.isGameOver || !gameState.isPlayerTurn || gameState.player.remainingMovesThisTurn > 1) return
        const boots = gameState.player.inventory.find((item) => item.type === 'boots')
        if (boots && boots.quantity > 0) {
          boots.quantity--
          gameState.player.remainingMovesThisTurn = 2
          updateMessage(`${boots.name}を使用！2回移動できます。`, 'info');
          updateInventoryUI()
        }
      }

      function useCloakItem() {
        if (gameState.isGameOver || !gameState.isPlayerTurn || gameState.player.cloakTurnsLeft > 0) return
        const cloak = gameState.player.inventory.find((item) => item.type === 'cloak')
        if (cloak && cloak.quantity > 0) {
          cloak.quantity--
          gameState.player.cloakTurnsLeft = CLOAK_DURATION
              updateMessage(`${cloak.name}を使用！${CLOAK_DURATION}ターンの間、見つかりにくくなります。`, 'info');
          updateInventoryUI()
        }
      }

      function mobsTurn() {
        if (gameState.isGameOver) return
        let isGameOver = false

        gameState.mobs.forEach((mob) => {
          const stats = MOB_STATS[mob.level]
          const distanceToPlayer = Axial.distance(mob.pos, gameState.player.pos)
          let bestMove = mob.pos
          let canDetectPlayer = true
          if (gameState.player.cloakTurnsLeft > 0 && Math.random() < CLOAK_EVASION_CHANCE) {
            canDetectPlayer = false
          }
          if (canDetectPlayer && distanceToPlayer <= stats.detectionRange) {
            let minDistance = distanceToPlayer
            let bestMoves = [mob.pos]; // 最適な移動先候補を配列で保持
            const neighbors = Axial.neighbors(mob.pos)
            for (const neighbor of neighbors) {
              if (
                gameState.grid.has(`${neighbor.q},${neighbor.r}`) &&
                !gameState.mobs.some((m) => m.pos.q === neighbor.q && m.pos.r === neighbor.r)
              ) {
                const d = Axial.distance(neighbor, gameState.player.pos)
                if (d < minDistance) { // より近いマスが見つかった場合
                  minDistance = d
                  bestMoves = [neighbor]; // 候補をリセットして新しい最適解を追加
                } else if (d === minDistance && d < distanceToPlayer) { // 同じ距離でより近いマスが見つかった場合
                  bestMoves.push(neighbor); // 候補に追加
                }
              }
            }
            if (bestMoves.length > 1 && bestMoves[0] === mob.pos && minDistance === distanceToPlayer) { // 移動先がない場合（現在地が唯一の最適解）は現在地を維持
              bestMove = mob.pos;
            } else if (bestMoves.length > 0 && bestMoves[0] !== mob.pos) { // 移動可能な最適解がある場合
              bestMove = bestMoves[Math.floor(Math.random() * bestMoves.length)]; // 候補からランダムに選択
            }
          } else {
            const neighbors = Axial.neighbors(mob.pos)
            const validMoves = neighbors.filter(
              (n) =>
                gameState.grid.has(`${n.q},${n.r}`) && !gameState.mobs.some((m) => m.pos.q === n.q && m.pos.r === n.r)
            )
            if (validMoves.length > 0) {
              bestMove = validMoves[Math.floor(Math.random() * validMoves.length)]
            }
          }
          mob.pos = bestMove
          createOrUpdatePiece(mob, 'mob')
          if (Axial.distance(mob.pos, gameState.player.pos) === 0) isGameOver = true
        })

        if (isGameOver) {
          setTimeout(endGame, 300)
          return
        }

        if (!gameState.isGameOver) {
          spawnItem()
          // ★毎ターン終了時に確率で新しいモンスターをスポーン
          const mobCount = gameState.mobs.length;
          const maxCapacity = gameState.maxMobCapacity || 10; // gameStateにmaxMobCapacityがなければデフォルト10
          const occupancyRate = Math.min(1.0, mobCount / maxCapacity); // 0.0 ~ 1.0

          const exponent = 2; // この値を調整することで変化の度合いを変える (例: 1, 1.5, 2, 3)
          // 占有率が低いほどスポーン確率が高くなるように調整
          // (1 - occupancyRate) が0に近いほど確率が低く、1に近いほど確率が高い
          let dynamicSpawnChance = MOB_SPAWN_CHANCE_PER_TURN * Math.pow(1 - occupancyRate, exponent);

          if (Math.random() < Math.max(0.05, Math.min(0.95, dynamicSpawnChance))) { // 最低5%, 最高95%の確率
            spawnNewMob();
          }

          gameState.turn++
          gameState.isPlayerTurn = true
          gameState.player.remainingMovesThisTurn = 1
          updateInfo()
          updateInventoryUI()
          highlightValidMoves()
          clearDetectionHighlights()
          if (gameState.player.cloakTurnsLeft > 0) {
            updateMessage(`あなたのターンです。(隠れ蓑効果: 残り${gameState.player.cloakTurnsLeft}ターン)`);
          } else { // このメッセージは「ヘクス」を含んでいないので変更なし
            updateMessage('あなたのターンです。移動したいマスを選択してください。');
          }
        }
      }

      function endGame() {
        gameState.isPlayerTurn = false
        gameState.isGameOver = true
        updateMessage(`ゲームオーバー！最終スコア: ${gameState.score}`, 'gameover');
        gameState.grid.forEach((hex) => {
          if (hex.el) {
            // hex.elが存在するか確認
            hex.el.classList.remove('highlight')
            hex.el.classList.remove('detection-highlight')
          }
        })
      }

      function updateInfo() {
        scoreEl.textContent = gameState.score
        turnEl.textContent = gameState.turn
      }

      function updateInventoryUI() {
        inventoryArea.innerHTML = ''
        gameState.player.inventory.forEach((item) => {
          if (item) {
            const itemDiv = document.createElement('div')
            itemDiv.className = 'inventory-item'

            const iconSpan = document.createElement('span')
            iconSpan.className = 'item-icon'
            iconSpan.textContent = item.icon || ''
            itemDiv.appendChild(iconSpan)

            const textSpan = document.createElement('span')
            let itemText = `${item.name}: ${item.quantity}個`
            if (item.type === 'cloak' && gameState.player.cloakTurnsLeft > 0) {
              itemText += ` (効果中: 残り${gameState.player.cloakTurnsLeft}ターン)`
            }
            textSpan.textContent = itemText
            itemDiv.appendChild(textSpan)
            inventoryArea.appendChild(itemDiv)

            if (item.type === 'boots') {
              const useButton = document.createElement('button')
              useButton.textContent = '使用'
              useButton.onclick = useBootsItem
              inventoryArea.appendChild(useButton)
              if (!gameState.isPlayerTurn || gameState.player.remainingMovesThisTurn > 1 || item.quantity === 0) {
                useButton.disabled = true
              }
            } else if (item.type === 'cloak') {
              const useButton = document.createElement('button')
              useButton.textContent = '使用'
              useButton.onclick = useCloakItem
              inventoryArea.appendChild(useButton)
              if (!gameState.isPlayerTurn || gameState.player.cloakTurnsLeft > 0 || item.quantity === 0) {
                useButton.disabled = true
              }
            }
          }
        })
      }

      restartButton.addEventListener('click', () => {
        const selectedRadius = parseInt(mapSizeSelector.value);
        // DOMの表示更新が完了した後にinitGameを呼び出す (タイミング問題を避けるため)
        requestAnimationFrame(() => initGame(selectedRadius));
      })

      // 初期ゲーム開始
      requestAnimationFrame(() => initGame(parseInt(mapSizeSelector.value))); // リセット時と同じ呼び出し方にする
    </script>
  </body>
</html>
